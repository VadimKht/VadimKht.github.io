#version 300 es

out vec2 v_texcoord;

//posx,      posy,        rot
//texX,      texY         texIndscale,
//scaleX,    scaleY,      emptySlot
uniform mat3 positions[64];
float spriteNormalized = 1.0/12.0;

vec2 Cube[6] = vec2[6](
    vec2(-1.0, 1.0), vec2(-1.0, -1.0), vec2(1.0, -1.0),
    vec2(-1.0, 1.0), vec2(1.0, 1.0), vec2(1.0, -1.0)
);

// Vertically flips texture because writing from framebuffer to texture flips it so we reflip to look normal again
const vec2 TexCoord[6] = vec2[6](
    vec2(0.0, 1.0), vec2(0.0, 0.0), vec2(1.0, 0.0),
    vec2(0.0, 1.0), vec2(1.0, 1.0), vec2(1.0, 0.0)
);

void main(void) {
    // angles to rads
    float angle = positions[gl_InstanceID][0][2] * 0.0174533;

    vec2 scaledCube = vec2(Cube[gl_VertexID%6].x * positions[gl_InstanceID][2][0],
                            Cube[gl_VertexID%6].y * positions[gl_InstanceID][2][1]);
    vec2 rotatedCube = vec2(scaledCube.x * cos(angle) - scaledCube.y * sin(angle), 
                            scaledCube.x * sin(angle) + scaledCube.y * cos(angle));

    gl_Position = vec4(rotatedCube + vec2(positions[gl_InstanceID][0]), 0.0, 1.0);

    // select right cell in texture and scale correctly by uniform data
    v_texcoord = vec2(
        // First we make cell smaller to fit one cell based by spritenormalized, then scale how much of texture we want (Normally should allow x and y values but i chose both at same time)
        TexCoord[gl_VertexID%6]*spriteNormalized*positions[gl_InstanceID][1][2] + 
        // Then we add the x,y position of cell given one cell is spritenormalized*x/y size
        vec2(spriteNormalized*positions[gl_InstanceID][1][0], spriteNormalized*positions[gl_InstanceID][1][1]));
}